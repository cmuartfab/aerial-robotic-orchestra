//OutPin is the pin that the PWM is sent to and connected to all the 4 ESCs
#define OutPin 9
volatile unsigned long time_1 = 0;
volatile unsigned long time_0 = micros();

//The Pre-arm on time in PWM
#define prearm_on_time 900 //Pre-arm on time

//Limits of the on-time of PWM sent to the ESCs
#define max_on_time 1860 //ESC Upper Lim
#define min_on_time 1060 //ESC Lower Lim

//Duration of the square wave
#define m_dur 100 //per note duration :: playnotes()
volatile unsigned long count = 0;
volatile unsigned long duty_cycle = 0;
unsigned long int note = min_on_time;
int limit = 0; //hold
//int notes[10] = {1062, 1110, 1200, 1260, 1200, 1320, 1350, 1260, 1350, 1200};
//int NoteLength[10] = {3000, 2700, 2700, 2700, 2700, 2400, 2400, 2100, 2400, 2400};

//PWM of notes starting from G. each new idex is the next semitone
// G, G#, A, A#,B,C
//float notes[50] = {850,870,885,900, 919,940, 946, 961, 975,987, 1011, 1037, 1060, 1086, 1111, 1136, 1161, 1186}; //1186, 1211, 1236, 1261, 1286, 1311};/int NoteLength[50] = {1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000 };
//float NoteLength[50] = {1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000};

//Next array is used if we interface this code to PD. Currently it is not in use
//A4 to A5
float frequencies[15] = {440, 466.14, 493.88, 523.25, 554.37, 587.33, 622.25, 659.25, 698.46, 739.99, 830.61, 880};

//int NoteLength[10] = {3000, 2700, 2700, 2700, 2700, 2400, 2400, 2100, 2400, 2400};

//PWM on time of Notes for smoke on the water. Tuned by ear, mobile piano and PD. starts with G
float notes[50] = {919, 990, 1045, 919, 990, 1063, 1045, 919, 990, 1045, 990, 919}; //1186, 1211, 1236, 1261, 1286, 1311};
float NoteLength[50] = {1000, 1000, 2000, 1000, 1000, 500, 2000, 1000, 1000, 2000, 1000, 2000};

//A scaling factor that we used to move from different Octaves. Do not changes this. It may require tuning from square one.
float scale = 1.3 / 0.82;
void setup()
{
  // Serial.begin(9600);
 // Serial.begin(9600); // opens serial port, sets data rate to 9600 bps
  pinMode(OutPin, OUTPUT);   // sets the pin as output
}

void loop()
{

  //Arm and prearm process
  while (1) {
    duty_cycle = prearm_on_time + count;
    if ((micros() - time_0) < duty_cycle) {
      //turn signal to one
      digitalWrite(OutPin, 1);
    }
    else if ((micros() - time_0) >= duty_cycle && (micros() - time_0) < 20064) {
      //turn to zero
      digitalWrite(OutPin, 0);
    }
    else if ((micros() - time_0) >= 20064 && duty_cycle <= min_on_time) {
      time_0 = micros();
      count += 1;
      //limit++;
    }
    else if (duty_cycle > min_on_time)
      break;

    // Serial.println(limit);
    if (duty_cycle >= max_on_time) {
      count = 0;
    }
  }
  count = 0;

  //Armed the ESCs, Now play notes!
  while (1) {
    unsigned long curr_time = 0;
    for (int i = 0; i < 16 ; i++)
    {
      curr_time = millis() + NoteLength[i];
      while (1) {
        if ((curr_time - millis()) > 0) {
          play_note(scale * notes[i], frequencies[i], m_dur);
        }
        else
          break;
      }
    }
  }
}

void play_note(unsigned long int note, float freq, unsigned long duration) {
  char character;
  boolean flag;
  float pd_value;

  //Add current time to duration
  duration += millis();
  float P = 0.01;
  //float I = 0;
  //float D = 0;

  duty_cycle = note;
  //run loop till duration of note
  while ((duration - millis()) > 0 ) {
    //duty_cycle = min_on_time + count;
    //duty_cycle calculates using PID
    // error = freq - pd_value;
    //  duty_cycle = P*error + duty_cycle;
    // On time!
    if ((micros() - time_0) < duty_cycle) {
      //turn signal to one
      digitalWrite(OutPin, 1);
    } // Off time
    else if ((micros() - time_0) >= duty_cycle && (micros() - time_0) < 20064) {
      //turn to zero
      digitalWrite(OutPin, 0);


      // Code for PD interface. We put this here so that reading happens only in PWM Off-time
      //    String Data = "";
      //    flag=false;
      //    while(Serial.available()) {
      //     character = Serial.read();
      //     Data.concat(character);
      //     flag=true;
      //     delay(3);
      //    }
      //    if(flag)
      //    {
      //      float pd_value = Data.toFloat();
      //    }

    }
    //  else if ((micros() - time_0) >= 20064 && duty_cycle <= note) {
    //Restart the Pulse!
    else if ((micros() - time_0) >= 20064) {
      time_0 = micros();
      //count += 3;
      //limit++;
    }
    //  else if (duty_cycle > note)
    //   time_0 = micros();

    // Serial.println(limit);
    // if (duty_cycle >= max_on_time) {
    //   count = 0;
    //  }
  }
}
